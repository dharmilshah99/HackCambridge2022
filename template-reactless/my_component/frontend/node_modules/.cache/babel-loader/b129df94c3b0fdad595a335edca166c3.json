{"ast":null,"code":"import { Streamlit } from \"streamlit-component-lib\"; // Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\n\nconst span = document.body.appendChild(document.createElement(\"span\"));\nconst textNode = span.appendChild(document.createTextNode(\"\"));\nconst button = span.appendChild(document.createElement(\"button\"));\nbutton.textContent = \"Click Me!\"; // Add a click handler to our button. It will send data back to Streamlit.\n\nlet numClicks = 0;\nlet isFocused = false;\n\nbutton.onclick = function () {\n  // Increment numClicks, and pass the new value back to\n  // Streamlit via `Streamlit.setComponentValue`.\n  // numClicks += 1\n  // Streamlit.setComponentValue(numClicks)\n  navigator.mediaDevices.getUserMedia({\n    audio: true\n  }).then(stream => {\n    console.log({\n      stream\n    });\n    if (!MediaRecorder.isTypeSupported('audio/webm')) return alert('Browser not supported');\n    const mediaRecorder = new MediaRecorder(stream, {\n      mimeType: 'audio/webm'\n    });\n    const socket = new WebSocket('wss://api.deepgram.com/v1/listen', ['token', '7e3ea4dfb0238df8ba87d72fc46ed37e19984beb']);\n\n    socket.onopen = () => {\n      console.log({\n        event: 'onopen'\n      });\n      mediaRecorder.addEventListener('dataavailable', async event => {\n        if (event.data.size > 0 && socket.readyState == 1) {\n          socket.send(event.data);\n        }\n      });\n      mediaRecorder.start(1000);\n    };\n\n    let liveFeed = '';\n\n    socket.onmessage = message => {\n      const received = JSON.parse(message.data);\n      const transcript = received.channel.alternatives[0].transcript;\n\n      if (transcript && received.is_final) {\n        console.log(transcript);\n        liveFeed += transcript + ' ';\n        Streamlit.setComponentValue(liveFeed);\n      }\n    };\n\n    socket.onclose = () => {\n      console.log({\n        event: 'onclose'\n      });\n    };\n\n    socket.onerror = error => {\n      console.log({\n        event: 'onerror',\n        error\n      });\n    };\n  });\n};\n\nbutton.onfocus = function () {\n  isFocused = true;\n};\n\nbutton.onblur = function () {\n  isFocused = false;\n};\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\n\n\nfunction onRender(event) {\n  // Get the RenderData from the event\n  const data = event.detail; // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n\n  if (data.theme) {\n    // Use CSS vars to style our button border. Alternatively, the theme style\n    // is defined in the data.theme object.\n    const borderStyling = `1px solid var(${isFocused ? \"--primary-color\" : \"gray\"})`;\n    button.style.border = borderStyling;\n    button.style.outline = borderStyling;\n  } // Disable our button if necessary.\n\n\n  button.disabled = data.disabled; // RenderData.args is the JSON dictionary of arguments sent from the\n  // Python script.\n\n  let name = data.args[\"name\"]; // Show \"Hello, name!\" with a non-breaking space afterwards.\n\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160); // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n\n  Streamlit.setFrameHeight();\n} // Attach our `onRender` handler to Streamlit's render event.\n\n\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender); // Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\n\nStreamlit.setComponentReady(); // Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\n\nStreamlit.setFrameHeight();","map":{"version":3,"sources":["/home/jfeng/projects/component-template/template-reactless/my_component/frontend/src/index.tsx"],"names":["Streamlit","span","document","body","appendChild","createElement","textNode","createTextNode","button","textContent","numClicks","isFocused","onclick","navigator","mediaDevices","getUserMedia","audio","then","stream","console","log","MediaRecorder","isTypeSupported","alert","mediaRecorder","mimeType","socket","WebSocket","onopen","event","addEventListener","data","size","readyState","send","start","liveFeed","onmessage","message","received","JSON","parse","transcript","channel","alternatives","is_final","setComponentValue","onclose","onerror","error","onfocus","onblur","onRender","detail","theme","borderStyling","style","border","outline","disabled","name","args","String","fromCharCode","setFrameHeight","events","RENDER_EVENT","setComponentReady"],"mappings":"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","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\n// Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\nconst span = document.body.appendChild(document.createElement(\"span\"))\nconst textNode = span.appendChild(document.createTextNode(\"\"))\nconst button = span.appendChild(document.createElement(\"button\"))\nbutton.textContent = \"Click Me!\"\n\n// Add a click handler to our button. It will send data back to Streamlit.\nlet numClicks = 0\nlet isFocused = false\nbutton.onclick = function(): void {\n  // Increment numClicks, and pass the new value back to\n  // Streamlit via `Streamlit.setComponentValue`.\n  // numClicks += 1\n  // Streamlit.setComponentValue(numClicks)\n  navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {\n    console.log({ stream })\n    if (!MediaRecorder.isTypeSupported('audio/webm'))\n      return alert('Browser not supported')\n    const mediaRecorder = new MediaRecorder(stream, {\n      mimeType: 'audio/webm',\n    })\n    const socket = new WebSocket('wss://api.deepgram.com/v1/listen', [\n      'token',\n      '7e3ea4dfb0238df8ba87d72fc46ed37e19984beb',\n    ])\n    socket.onopen = () => {\n      console.log({ event: 'onopen' })\n      mediaRecorder.addEventListener('dataavailable', async (event) => {\n        if (event.data.size > 0 && socket.readyState == 1) {\n          socket.send(event.data)\n        }\n      })\n      mediaRecorder.start(1000)\n    }\n\n    let liveFeed = ''\n    socket.onmessage = (message) => {\n      const received = JSON.parse(message.data)\n      const transcript = received.channel.alternatives[0].transcript\n      if (transcript && received.is_final) {\n        console.log(transcript)\n        liveFeed+=\n          transcript + ' '\n        Streamlit.setComponentValue(liveFeed)\n      }\n    }\n\n    socket.onclose = () => {\n      console.log({ event: 'onclose' })\n    }\n\n    socket.onerror = (error) => {\n      console.log({ event: 'onerror', error })\n    }\n  })\n}\n\nbutton.onfocus = function(): void {\n  isFocused = true\n}\n\nbutton.onblur = function(): void {\n  isFocused = false\n}\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n  if (data.theme) {\n    // Use CSS vars to style our button border. Alternatively, the theme style\n    // is defined in the data.theme object.\n    const borderStyling = `1px solid var(${\n      isFocused ? \"--primary-color\" : \"gray\"\n    })`\n    button.style.border = borderStyling\n    button.style.outline = borderStyling\n  }\n\n  // Disable our button if necessary.\n  button.disabled = data.disabled\n\n  // RenderData.args is the JSON dictionary of arguments sent from the\n  // Python script.\n  let name = data.args[\"name\"]\n\n  // Show \"Hello, name!\" with a non-breaking space afterwards.\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160)\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"]},"metadata":{},"sourceType":"module"}